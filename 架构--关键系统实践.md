### 互联网注册中心设计与实践

> 注册中心是AP模型，可用性
>
> 分布式锁是CP模型，一致性
>
> CP : zookeeper、etcd
>
> AP：Eureka（适合做注册中心）

#### zookeeper

##### 功能

* 文件系统
* 通知机制

##### 分布式程序协调服务

* 节点选主
* 配置管理
* 粗粒度分布式锁
* 主备高可用切换
* 服务注册
* 服务发现

##### 注册中心本质

* 查询
  * 服务名称查询参数
  * 查询服务可用的ip和端口列表
* 对数据一致性要求不高，最终一致性
  * 不一致的影响：节点流量不均衡

##### zookeeper作为注册中心缺点

* zookeeper集群发生网络分区时，同机房的服务不可调用，因为zookeeper注册中心自身为保脑裂下的数据一致性而放弃可用性。zookeeper是cp模型

* 互联网微服务规模剧增情况下：
  * 服务规模超过一定数量，zookeeper将会不堪重负
  * 服务发布大量注册写请求
  * 毫秒级服务健康状态的写请求
  * 服务与注册中心海量长连接
  * zookeeper写节点是单点，不能水平扩展，解决方法：
    * 按照业务功能垂直拆分为不同zk集群，这样会破坏不同业务的服务连通性，同时业务整合连通不可预知。比如：商品注册中心、交易注册中心、搜索注册中心、推荐注册中心，假如搜索和推荐业务合并就很麻烦，合并导致大量服务的写请求。
  * 不需要存储（zookeeper为了一致性存储了以下信息）
    * 核心数据：实时健康的服务列表
    * zab协议对每个写请求在节点上保持写一个事务日志
    * 定期将内存数据镜像dump到磁盘，保持数据一致性和持久性
    * 调用方并不关心服务的历史地址列表、过去的健康状态
  * 需要存储
    * 服务的元数据信息
      * 服务的版本、分组、所在机房、权重、鉴权策略信息、服务标签等元信息
  * 探活机制，利用zookeeper的session活性跟踪机制以及节点特性，存在问题：
    * 服务健康情况无法真正探测
    * 服务假死问题

##### 注册中心容灾

> 注册中心不能因为自身的任何原因破坏服务之间本身的可连通性

* 服务调用链路需要弱依赖注册中心，只有服务发布、机器上下线、服务扩容缩容等才强依赖
* 客户端设计考虑容灾
  * 缓存数据机制
  * zk节点宕机，应用服务是否正常work
  * 原生zk客户端并不具有，curater比原生（zkclient）好

##### zookeeper适用场景

* 适用场景：大数据、分布式协调
* 不适用场景：大规模交易(交付)、大规模服务发现



### 互联网分布式配置中心设计与实践

  #### Apollo

* 统一管理不同环境、不同集群的配置
  * Apollo提供了一个统一界面集中式管理不同环境、不同集群、不同命名空间的配置
* 配置修改实时生效(热发布)
  * 用户在Apollo修改完配置并发布后，客户端能实时(1秒)接收到最新的配置，并通知到应用程序
* 版本发布管理
  * 所有的配置发布都有版本概念，从而可以方便的支持配置的回滚
* 权限管理、发布审核、操作审计
* 客户端配置信息监控
  * 可以方便的看到配置在被哪些实例使用
* 提供Java与.Net原生客户端
  * 同时提供了HTTP接口，非Java和.Net应用也可以方便的使用
* 部署简单
  * 配置中心作为基础服务，可用性要求非常高，这就要求Apollo对外部依赖尽可能少
  * 目前唯一的外部依赖是mysql，所以部署非常简单，只要安装好Java和mysql就可以让Apollo跑起来
  * Apollo还提供了打包脚本，一键就可以生成所有需要的安装包，并且支持自定义运行时参数
* 提供开发平台API
  * 对于有些使用方，它们的配置可能会比较复杂的格式，如XML、JSON，需要对格式做校验，提供开放接口自定义

##### Apollo基础模型

* 用户在配置中心对配置进行修改并发布
* 配置中心通知Apollo客户端有配置更新
* Apollo客户端从配置中心拉取最新的配置、更新本地配置并通知到应用

##### Apollo总体架构

![image-20190917002910222](/Users/xiaocuicao/Library/Application Support/typora-user-images/image-20190917002910222.png)



### 互联网分布式消息队列设计与实践

#### 消息队列应用场景

* 异步通信
* 解耦业务：基于消息模型，关注"通知"，而非关注"处理"
* 错峰与流控
* 广播
* 时序保证

#### 消息队列模型

* Pub/Sub发布订阅(广播)
  * 使用Topic作为通信载体
* P2P点对点
  * 使用Queue作为通信载体

#### 消息队列构成

* Broker：消息服务器
* Producer：消息生产者
* Consumer：消息消费者
* Topic：主题
* Queue：队列
* Message：消息体

#### 消息队列设计考虑点

##### 消息队列设计

* RPC通信协议
* 存储选型
* 事务处理
* 消费关系处理
* 数据去重处理
* 数据丢失处理
* 批量处理
* 异步与性能
* 高可用/高扩展

##### 不同队列特性

* 消息丢失概率
* 消息重复可能
* 消息堆积能力
* 顺序消息保证
* 事务处理特性
* 错峰流控能力
* 延迟敏感性
* 数据一致性
* 慢消息处理

#### 消息队列高级特性设计

* 可靠投递
* 消费确认
* 重复消息和顺序消息
  * At More Once
  * Only Once
  * At Least Once
* 性能考虑
  * 同步/异步
  * 批量
* Push or Pull

 #### 消息队列知名产品

##### Kafka

* Scala语音开发

* 高性能分布式Pub/Sub消息队列系统

* 适用场景

  * 高吞吐量

    > 高可靠性可容忍场景，丢几条日志信息可容忍

  * 日志处理

* HA

  * Zookeeper

##### RocketMQ

* 特性
  * 能够保证严格的消息顺序
  * 提供针对消息的过滤功能
  * 提供丰富的消息拉取模式
  * 高效的订阅者水平扩展能力
  * 实时的消息订阅机制
  * 亿级消息堆积能力
* 适用场景
  * 消息高可靠
  * 电商场景：比如订单消息

##### RocketMQ刷盘策略

* 异步刷盘
  * 写完PageCache直接返回
  * RocketMQ可配置
* 同步刷盘
  * 写入PageCache，线程等待，通知刷盘线程刷盘
  * 刷盘线程刷盘后，唤醒前端等待线程，可能是一批线程
  * 前端等待线程向用户返回成功

### 互联网分布式请求跟踪系统设计与实践

#### 分布式请求跟踪系统设计目标

* 低侵入性
* 灵活的应用策略
* 时效性
* 决策支持
* 可视化

























































































