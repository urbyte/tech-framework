## 1.高可用设计手段

>案例：
>
>* 微博服务突发大流量
>* 服务突发大流量双11案例

#### 微服务高可用设计手段

* 无状态化：服务冗余：不同机房、不同机柜、不同机架部署多份实例，无状态化(保证服务对等)

  > 无状态化的目的：快速的扩容、弹性的缩容

* 负载均衡：幂等设计

  > gateway-> 业务逻辑层1、业务逻辑层2，如何让网关知道业务逻辑层1挂掉？

* 异步化设计：超时机制

  > 异步化设计：提供吞吐量，不关心的结果、不是主流程、边缘流量、非核心流量

* 服务限流降级熔断：数据复制/缓存/Sharding

  > 缓存：提高访问速度、减轻数据库的压力

* 架构拆分、服务治理

#### 服务实时监控

* 5s写一次日志，flume采集日志到kafka

#### 服务分级

* 服务级别：
  * 一级服务：服务每天pv到达5000w以上
  * 二级服务：服务每天pv到达1000w以上
  * 三级服务：其他

#### 高可用案例

* 网关层已具备热切换能力

  > 如何判断服务已接收的请求已处理完毕：1.观察业务逻辑层日志输出情况，若没有日志输出就表示已接收的请求已处理完；2.根据网关层配置的超时机制来判断，更优雅，比如超时时间为10s，在切流量后10s已接收的请求肯定已返回或超时了。

  * 热开关切换

* 网关层不具备热切换能力

  * 防火墙限制只出不进
    * IPTABLES

 ## 2.高并发设计手段

####  系统性能

> 性能优化目标
>
> * 缩短响应时间
> * 提高并发数(增加吞吐量)
> * 让系统处于合理状态

* 吞吐量
* 响应延迟

#### 优化手段

* 空间换时间

  * 系统时间是瓶颈，比如：缓存复用计算结果，降低时间开销，因为CPU时间较内存容量更加昂贵

* 时间换空间

  * 数据大小是瓶颈

    > 1.网络传输是瓶颈，使用系统时间换取传输的空间，使用HTTP的gzip压缩算法
    >
    > 2.App的请求分类接口，使用版本号判断哪些数据更新，只下载更新数据

* 找到系统瓶颈
  * 分析系统业务流程，找到关键路径并分解优化
  * 一个服务集群4w的QPS，调用量前5的接口贡献了3.5w的QPS
  * 对关键路径的代码优化收益最大，当然系统剩下的部分也不能忽视，比如剩下5k的QPS接口若性能有问题也可能把整体服务性能拖垮

> 调用了多少RPC接口；载入多少数据；使用什么算法；
>
> 非核心流程能否异步化；没有数据依赖的逻辑能否并行执行

#### 优化层次

* 架构设计层次
  * 关注系统控制、数据流程
  * 如何拆分系统，如何使各部分系统整体负载更加均衡，充分发挥硬件设施性能优势，减少系统内部开销等
* 算法逻辑层次
  * 关注算法选择是否高效，算法逻辑优化，空间时间优化任务并行处理，使用无锁数据结构等
  * 空间换时间：ThreadLocal
  * 时间换空间：采用压缩算法压缩数据，更复杂的逻辑减少数据传输
* 代码优化层次
  * 关注代码细节优化，代码实现是否合理，是否创建了过多的对象，循环遍历是否高效，cache使用的是否合理，是否重用计算结果等

> 优化层次：从整体到细节，从全局角度到局部视角

##### 代码优化层次

* 循环遍历是否合理高效，不用在循环里：调RPC接口、查询分布式缓存、执行SQL等

  > 先调批量接口组装好数据，再循环处理

* 代码逻辑避免生成过多对象或无效对象

  > ```java
  > if(logger.isDebugEnabled()) {
  >   logger.debug("debug log");
  > }
  > ```
  >
  > 输出log时候的log级别判断是没有必要的，会new 无效的对象

* ArrayList、HashMap初审容量设置是否合理：扩容的代价大
* 对数据对象是否合理重用，比如通过RPC查到的数据能缓存就缓存到下次重用
* 根据数据访问特性选择合适数据结构，比如读多写少：考虑CopyOnWriteArrayList(写时copy副本)
* 拼接字符串的时候是使用String相加还是使用StringBuilder进行append(在StringBuilder的容量预分配的情况下，StringBuilder的性能比String相加性能高15倍左右)

* 是否正确初始化数据，有些全局共享的数据，采用饿汉式模式，在用户访问之前先初始化好

##### 数据库代码优化层次

* 数据库建表语句能尽量小的数据结构
  * 表示状态的字段，如果状态值在255以内使用unsigned tinyint，IP使用int而非varchar
* 使用enum的场景使用tinyint替代，enum扩展需要改表
* 避免使用select * 查询数据，只查询需要的字段，避免浪费数据IO、内存、CPU、网络传输
* 分析查询场景建立合适的索引，分析字段的可选择性，索引长度，对比的varchar使用前缀索引
* 字段尽量为Not NULL 类型，MySQL手册说明允许NULL的字段需要额外的存储空间去处理NULL，并且很难查询优化
* 目的为了降低服务器CPU使用率、IO流量、内存占用、网络消耗，降低响应时间

##### 代码优化层次

* 业务系统使用缓存降低响应时间提高性能，必须提高缓存命中率
* 聚焦的高频访问，时效性要求不高很适合缓存提高性能，比如更新了可以不用实时体现，很适合使用缓存提升性能
* 对数据实时性要求很高，需要慎重考虑更新缓存带来的一致性问题
* 时效性和缓存的冲突，比如商品服务对商品进行了缓存，由于更新缓存和更新商品不是同一个事务，则对数据时效性要求高的比如交易，就只能直接从数据库查商品信息

##### 算法逻辑优化层次

* 高效算法替换现有算法，而不改变其接口
* 增量式算法，复用之前的计算结果，比如报表服务，从全量数据中生成报表数据量很大，但是每次增量的数据较少，则可以考虑只计算增量数据和之前的计算结果合并，这样处理的数据量就小很多
* 并发和锁的优化，读多写少的业务场景下，基于CAS的LockFree比mutex性能更好
* 当系统时间是瓶颈，采用空间换时间逻辑算法，分配更多空间节省系统时间
  * 缓存复用计算结果，降低时间开销，CPU时间较内存容量更加昂贵
* 当系统空间容量是瓶颈，采取时间换空间算法策略
  *  网络传输是瓶颈，使用系统时间换取空间的压缩，HTTP的gzip压缩算法
  * APP的请求分类接口，使用版本号判断哪些数据更新，只下载更新的数据，使用更多的代码逻辑处理更细粒度的数据
* 并行执行，比如一段逻辑调用了多个RPC接口，而这些接口之间并没有数据依赖，则可以考虑并行调用，降低响应时间
* 异步执行，分析业务流程中的主次流程，把次要流程拆分出来异步执行，更进一步可以拆分到单独的模块去执行，比如使用消息队列，彻底和核心流程解耦，提高核心流程的稳定性以及降低响应时间

###### 秒杀系统架构思路

* 数据分层次校验，上层尽量把无效请求过滤掉
* 上层可以是不精确的过滤
* 层层限流，最后一层做数据一致性校验，扣减库存

###### 秒杀系统架构设计

* HTML、JS、CSS等静态文件存放CDN，缓存到用户端(APP/浏览器)
* 非实时动态数据(秒杀期间如商品标题、商品描述、图片URL列表、店铺信息、秒杀活动信息等)，这些数据缓存在用户访问链路中靠近用户的位置，粗过滤一部分流量，比如用户是否有秒杀资格、秒杀是否已结束等，这些数据实时性要求不高
* 实时数据如用户营销数据(如红包、折扣)、商品库存等再过滤一批用户
* 经过多层过滤最终落到数据库的流量已经很少，最终在数据库层面使用事务保证扣减库存准确性

###### Feed系统消息发布

* 基于写扩散消息统一推送通道
* 推送策略：拆分数据并行推，活跃用户先推，非活跃用户慢慢推
  * 有1w个用户关注，发了一个feed，拆分成100份，每份100个并行推
  * 1w个用户里活跃的可能有2000个，活跃用户先推，非活跃用户慢慢推，保证活跃用户体验，非活跃用户推了很大概率也不看
* 消息标准化格式
* 统一数据数据流，职责明确

## 3.服务无状态化设计

>无状态化设计的目的：
>
>* 快速扩容服务
>* 弹性缩容服务

#### 服务无状态化定义

* 冗余部署的多个模块(进程)完全对等
* 请求提交到冗余部署的任一模块，处理结果完全一样
* 模块不存储业务的上下文信息
* 仅根据每次请求携带数据进行相应的业务逻辑处理

##4.服务负载均衡设计与实践

#### 负载均衡系统

##### 硬件

* F5
* A10
* Radware

##### 软件

* LVS 
  * 4层
* Nginx
  * 7层
* HAProxy
  * 4层或7层

##### 反向代理VS正向代理

#### 负载均衡算法

##### Dubbo LoadBalance

* Random
  * 随机，按权重设置随机概率
* RoundRobin
  * 轮询，按约定后的权重设置轮询比率
* ConsistentHash
  * 一致性hash，相同参数的请求总是发到同一个提供者 

#### 广义负载均衡

##### 完整的故障处理恢复机制

* 故障自动发现，注册中心发现(zookeeper、etcd、consul、eureka)、网关层发现

  >网关层到业务逻辑层采用PRC通信，即TCP；
  >
  >采用HTTP通信的缺点：1.传输body一个字节，头部内容多，IO量不高；2.HTTP是短连接，频繁的创建、关闭连接

* 故障服务自动摘除

  *  服务熔断机制(hystrix)

    > * Hystrix 缺点：需要引入jar包，实现它的command命令，不是在平台端做的事情
    >
    > * 重启业务逻辑层服务（挂掉的服务）步骤：jstack 3次（3次有比较性），kill pid，sleep 6s (超过zk的两次心跳时间，让zk通知网关层该服务连接)，start 

* 请求自动重试

* 服务恢复自动发现

## 5.服务幂等设计

#### 幂等定义

* 请求层面
  * 保证请求重复执行和执行一次结果相同
* 业务层面
  * 同一个用户不重复下单
  * 商品不超卖
  * MQ消费端去重

####幂等目的

* 为了请求重试
* 结果灾难性
  * 转账
  * 交易

#### 幂等范围

* 读/写请求层面
  * 写请求对数据造成改变
* 架构层层面
  * 哪些层面会对数据造成改变
    * 反向代理层 ？
    * 网关层 ？
    * 业务逻辑层 ？
    * 数据访问层，会对数据造成改变

#### 业务层面幂等

* 冗余部署多个进程
  * 存在并发消费的可能性，并发转变成串行消费
* 本质：分布式锁问题，比如MQ消费端，多个消费端防止重复消费，采用分布式锁处理

## 6.分布式锁设计

> 分布式锁是CP模型，Redis集群是AP模型，因为Redis 主从复制是半同步

#### 基于Redis分布锁

* 唯一线程串行处理
* 存在问题：
  * 锁时间不可控
    * 无法续租期
  * 单点问题
    * 单实例存在进程一旦死掉，会阻塞业务流程
    * 主从方式，主从数据异步，会存在锁失效问题
* 官方建议：Redis建议使用Redlock算法来保证，但是问题是需要至少三个Redis主从实例来完成，维护成本相对较高。Redlock等同于自己实现简单的一致性协议，细节繁琐，且容易出错

#### 高可用分布式锁设计目标

* 设计目标
  * 强一致性
  * 服务高可用、系统稳健
  * 锁自动续约及其自动释放
  * 代码高度抽象，业务接入极简
  * 可视化管理后台，监控及管理

## 7.分布式事务设计

#### 分布式事务分类

* 刚性分布式事务

  * 强一致性
  * XA模型，二阶段提交是XA规范标准的实现
  * CAP 
    * CP

  * 案例：2PC
    * 过程：TM发起prepare投票；RM都同意后，TM再发起commit；Commit过程出现宕机等异常，节点服务重启后，根据XA recover再次进行commit补偿
    * 缺点：同步阻塞模型；数据库资源锁定时间过长；全局锁(隔离级别串行化)，并发低；不适合长事务场景

* 柔性分布式事务，具体实现：TCC模型、Saga模型

  * 最终一致性
  * CAP、BASE理论
    * AP
  * 案例：TCC模型
    * Try：尝试执行业务，完成所有业务检查，预留必要的业务资源
    * Confirm：真正执行业务，不再做业务检查
    * Cancel：释放Try阶段预留的业务资源
    * TCC模型完全交由业务实现，每个子业务都需要实现Try-Confirm-Cancel接口，对业务侵入性大
      * 资源锁定交由业务方
  * 案例：Saga模型
    * Saga模型把一个分布式事务拆分为多个本地事务，每个本地事务都有相应的执行模型和补偿模块(对应TCC中的Confirm和Cancel)
    * 当Saga事务中任意一个本地事务出错时，可以通过调用相关的补偿方法恢复之前的事务，达到事务最终一致性
    * Saga隔离型
      * 业务层控制并发
        * 在应用层加锁
        * 应用层预先冻结资源等
    * Saga恢复方式
      * 向后恢复：补偿所有已完成的事务，如果任一子事务失败
      * 向前恢复：重试失败的事务，假设每个子事务最终都会成功 

#### 柔性分布式事务

* 通用处理思路
  * 本地事务-》短事务
  * 分布式事务-》长事务
  * 转变成多个短事务
* 业务场景：
  * 异步场景
    * 基于MQ消息驱动分布式事务
  * 同步场景
    * 基于异步补偿的分布式事务

##### 异步场景分布式事务设计

###### 方案一：MQ分布式事务消息设计

> * 业务方提供本地操作成功回查接口功能，对业务有侵入
>
> * MQ支持半消息：RocketMQ
> * 借鉴了两阶段提交理论

* 事务消息：MQ提供类型X/Open XA的分布式事务功能，通过MQ事务消息能达到分布式事务的最终一致

* 半消息：暂不能投递的消息，发送方已经将消息成功发送到MQ服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记成"暂不能投递"状态，处于该种状态下的消息即半消息

* 消息回查：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确认丢失，MQ服务端通过扫描发现某条消息长期处于"半消息"时，需要主动向消息生产者询问该消息的最终状态(Commit或是Rollback)，即消息回查

* 设计方案：

  ![image-20190806010902534](/Users/xiaocuicao/Library/Application Support/typora-user-images/image-20190806010902534.png)

* 优点：通用

* 缺点：

  * 业务方需提供回查接口，对业务侵入大
  * 发送消息非幂等
  * 消费端需要处理幂等

###### 方案二：本地事务消息表(实际场景使用较多)

* 本地操作和发送消息通过本地事务强一致性

  * 本地事务操作表
  * 本地事务消息表

  ![image-20190806012123324](/Users/xiaocuicao/Library/Application Support/typora-user-images/image-20190806012123324.png)

* 发送端消息不幂等：至少发送一次
* 消费端处理消息幂等
  * 分布式锁来处理
* A -> B -> C
  * A/B 成功，C失败
    * 记录错误日志
    * 报警
    * 人工介入
* 优点：业务侵入小

##### 同步场景分布式事务设计

###### 解决方案：

* 基于异步补偿的分布式事务
* 架构设计的三大关键点：记录请求调用链条，提供幂等补偿接口，基于补偿机制

###### 业务逻辑层proxy设置(基于AOP实现)

* 逻辑层调用上加事务注解@Around("execution(* *(..)) && @annotation(TX)")
* Proxy在真正业务逻辑被调用之前，生成一个全局唯一TXID标识事务组，TXID保存在ThreadLocal变量里，方法开始前写入，完成后清除，并向远端数据库写入TXID并把事务组置为开始状态
* 业务逻辑层调用数据库访问层之前，通过RpcProxy代理记录当前调用参数
* 业务正常，调用完成后，当前方法的调用记录存档或删除
* 业务异常，查询调用链反向补偿

######数据访问层设计

* 原子接口

* 补偿接口：谁提供，就幂等性保证

* 基于原子接口方法，在方法名加注解标注补偿方法名

  @Compensable(cancelMethod="cancelRecord")

###### 分布式事务补偿服务

* 事务组表
  * 记录事务组状态
  * txId、state、timestamp
* 事务调用组表
  * 记录事务组内的每一次调用以及相关参数
  * txId、actionId、callMethod、parmaType、params
* 补偿策略
  * 调用执行失败，修改事务组状态
  * 分布式事务补偿服务异步执行补偿

## 8.服务降级设计

#### 服务降级目的

* 流量高峰期
* 短时请求量大
* 服务能力有限
* 性能下降
* 系统雪崩
* 服务宕机

#### 服务降级目标

* 保证核心服务可用
* 非核心服务弱可用，甚至不可用

#### 服务降级手段

##### 关闭部分服务(业务相关)

##### 拒绝部分请求

* 拒绝部分老请求
  * 减轻微服务请求处理数量
  * 确保"新"请求正常响应
  * RPC队列方式(请求入队、出队时间处理请求时，检查请求在队列请求时间超过一定时间[比如1s]，直接丢弃)
* 优先级请求方式
  * 非核心请求直接丢弃
  * 业务紧密保留

> 条件：拒绝部分老请求，策略：优先级请求方式，配合使用

* 随机拒绝方式
  * 随机丢弃一定比例请求
  * 网站一会可用，一会不可用

#### 服务层降级架构层次

* 自治式(各自层负责降级)
  * 网关层
  * 业务逻辑层
  * 数据访问层

## 9.服务限流/熔断设计













## 10.服务灰度发布设计













## 11.服务全链路压测设计













## 12.千亿级真实案例实战





